package com.rohan.Khoj.config;

import com.rohan.Khoj.dto.*; // Import all DTOs (e.g., PatientDto, DoctorDto, ClinicDto, AppointmentDto, Request/Update DTOs, Affiliation DTOs)
// Explicit imports for inner classes (MobileNumberWrapperDto) for clarity in converters
import com.rohan.Khoj.dto.MobileNumberWrapperDTO;

import com.rohan.Khoj.entity.*; // Import all Entities (e.g., PatientEntity, DoctorEntity, ClinicEntity, AppointmentDetailEntity, DoctorClinicAffiliationEntity)
import org.modelmapper.ModelMapper;
import org.modelmapper.PropertyMap;
import org.modelmapper.Converter; // Import Converter
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.password.PasswordEncoder;

import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@Configuration
public class ModelMapperConfig {

    @Bean
    public ModelMapper modelMapper(PasswordEncoder passwordEncoder) {
        ModelMapper modelMapper = new ModelMapper();
        modelMapper.getConfiguration().setAmbiguityIgnored(true); // Allows multiple sources to map to same target (with skips)

        // --- Common Converters ---

        // Converter: Set<String> to List<String> (for phone numbers in response DTOs, to ensure consistent order)
        Converter<Set<String>, List<String>> setToListSortedConverter = context -> {
            if (context.getSource() == null) {
                return null;
            }
            return context.getSource().stream()
                    .sorted() // Natural alphabetical/numerical order for strings
                    .collect(Collectors.toList());
        };

        // --- Mappings for Patient Entities and DTOs ---

        // PatientRegistrationRequestDTO -> PatientEntity
        modelMapper.addMappings(new PropertyMap<PatientRegistrationRequestDTO, PatientEntity>() {
            @Override
            protected void configure() {
                map().setEmailId(source.getEmailId()); // DTO 'email' to Entity 'emailId'
                skip().setPassword(null);      // Handled in service
                skip().setId(null);                  // Generated by DB
                skip().setCreatedAt(null);           // Set by @PrePersist or service
                skip().setUpdatedAt(null);           // Set by @PreUpdate or service

                // Map phone numbers from wrapper DTO to entity's Set<String>
                using( (Converter<Set<MobileNumberWrapperDTO>, Set<String>>) context -> {
                    if (context.getSource() == null) return new HashSet<>(); // Initialize empty set if null
                    return context.getSource().stream()
                            .map(MobileNumberWrapperDTO::getNumber)
                            .collect(Collectors.toCollection(HashSet::new));
                }).map(source.getPhoneNumbers()).setPhoneNumbers(null);
            }
        });

        // PatientUpdateRequestDTO -> PatientEntity (for updating existing entity)
        modelMapper.addMappings(new PropertyMap<PatientUpdateRequestDTO, PatientEntity>() {
            @Override
            protected void configure() {
                skip().setUsername(null);           // Handled in service (uniqueness check with exclusion)
                skip().setEmailId(null);            // Handled in service (uniqueness check with exclusion)
                skip().setPassword(null);     // Handled in service (password hashing)
                skip().setId(null);
                skip().setCreatedAt(null);
                skip().setUpdatedAt(null);

                // Map phone numbers from wrapper DTO to entity's Set<String>
                using( (Converter<Set<MobileNumberWrapperDTO>, Set<String>>) context -> {
                    if (context.getSource() == null) return null; // If null, means no change to set
                    return context.getSource().stream()
                            .map(MobileNumberWrapperDTO::getNumber)
                            .collect(Collectors.toCollection(HashSet::new)); // Replace with new set
                }).map(source.getPhoneNumbers()).setPhoneNumbers(null);
            }
        });

        // PatientEntity -> PatientDto (for response/retrieval)
        modelMapper.addMappings(new PropertyMap<PatientEntity, PatientDTO>() {
            @Override
            protected void configure() {
                map().setEmailId(source.getEmailId()); // Ensure consistent mapping if field name varies
                // Use converter for phoneNumbers from Set<String> to List<String>
                using(setToListSortedConverter).map(source.getPhoneNumbers()).setPhoneNumbers(null);
            }
        });

        // --- Mappings for Doctor Entities and DTOs ---

        // DoctorRegistrationRequestDTO -> DoctorEntity
        modelMapper.addMappings(new PropertyMap<DoctorRegistrationRequestDTO, DoctorEntity>() {
            @Override
            protected void configure() {
                map().setEmailId(source.getEmailId());
                skip().setPassword(null);
                skip().setId(null);
                skip().setCreatedAt(null);
                skip().setUpdatedAt(null);
                skip().setClinicAffiliations(null); // Relationships set separately
                skip().setAppointments(null);

                // Map phone numbers
                using( (Converter<Set<MobileNumberWrapperDTO>, Set<String>>) context -> {
                    if (context.getSource() == null) return new HashSet<>();
                    return context.getSource().stream()
                            .map(MobileNumberWrapperDTO::getNumber)
                            .collect(Collectors.toCollection(HashSet::new));
                }).map(source.getPhoneNumbers()).setPhoneNumbers(null);
            }
        });

        // DoctorUpdateRequestDTO -> DoctorEntity
        modelMapper.addMappings(new PropertyMap<DoctorUpdateRequestDTO, DoctorEntity>() {
            @Override
            protected void configure() {
                skip().setUsername(null);
                skip().setEmailId(null);
                skip().setPassword(null);
                skip().setRegistrationNumber(null); // Handled in service
                skip().setId(null);
                skip().setCreatedAt(null);
                skip().setUpdatedAt(null);
                skip().setClinicAffiliations(null);
                skip().setAppointments(null);

                // Map phone numbers
                using( (Converter<Set<MobileNumberWrapperDTO>, Set<String>>) context -> {
                    if (context.getSource() == null) return null;
                    return context.getSource().stream()
                            .map(MobileNumberWrapperDTO::getNumber)
                            .collect(Collectors.toCollection(HashSet::new));
                }).map(source.getPhoneNumbers()).setPhoneNumbers(null);
            }
        });

        // DoctorEntity -> DoctorDto
        modelMapper.addMappings(new PropertyMap<DoctorEntity, DoctorDTO>() {
            @Override
            protected void configure() {
                using(setToListSortedConverter).map(source.getPhoneNumbers()).setPhoneNumbers(null);
            }
        });

        // --- Mappings for Clinic Entities and DTOs ---

        // ClinicRegistrationRequestDTO -> ClinicEntity
        modelMapper.addMappings(new PropertyMap<ClinicRegistrationRequestDTO, ClinicEntity>() {
            @Override
            protected void configure() {
                map().setName(source.getName()); // DTO 'name' to Entity 'name'
                map().setEmailId(source.getEmailId());
                skip().setPassword(null);
                skip().setId(null);
                skip().setCreatedAt(null);
                skip().setUpdatedAt(null);
                skip().setDoctorAffiliations(null);
                skip().setAppointments(null);

                // Map phone numbers
                using( (Converter<Set<MobileNumberWrapperDTO>, Set<String>>) context -> {
                    if (context.getSource() == null) return new HashSet<>();
                    return context.getSource().stream()
                            .map(MobileNumberWrapperDTO::getNumber)
                            .collect(Collectors.toCollection(HashSet::new));
                }).map(source.getPhoneNumbers()).setPhoneNumbers(null);
            }
        });

        // ClinicUpdateRequestDTO -> ClinicEntity
        modelMapper.addMappings(new PropertyMap<ClinicUpdateRequestDTO, ClinicEntity>() {
            @Override
            protected void configure() {
                skip().setUsername(null);
                skip().setEmailId(null);
                skip().setPassword(null);
                skip().setName(null); // Handled in service
                skip().setId(null);
                skip().setCreatedAt(null);
                skip().setUpdatedAt(null);
                skip().setDoctorAffiliations(null);
                skip().setAppointments(null);

                // Map phone numbers
                using( (Converter<Set<MobileNumberWrapperDTO>, Set<String>>) context -> {
                    if (context.getSource() == null) return null;
                    return context.getSource().stream()
                            .map(MobileNumberWrapperDTO::getNumber)
                            .collect(Collectors.toCollection(HashSet::new));
                }).map(source.getPhoneNumbers()).setPhoneNumbers(null);
            }
        });

        // ClinicEntity -> ClinicDto
        modelMapper.addMappings(new PropertyMap<ClinicEntity, ClinicDTO>() {
            @Override
            protected void configure() {
                using(setToListSortedConverter).map(source.getPhoneNumbers()).setPhoneNumbers(null);
            }
        });

        // --- Mappings for Appointment Entities and DTOs ---

        // AppointmentRequestDTO -> AppointmentDetailEntity
        modelMapper.addMappings(new PropertyMap<AppointmentRequestDTO, AppointmentDetailEntity>() {
            @Override
            protected void configure() {
                skip().setPatient(null); // Set in service
                skip().setDoctor(null);  // Set in service
                skip().setClinic(null);  // Set in service
                skip().setId(null);      // Generated by DB
                skip().setStatus(null);  // Set by service
                // skip().setCreatedAt(null); // Timestamps
                // skip().setUpdatedAt(null);
            }
        });

        // AppointmentUpdateRequestDTO -> AppointmentDetailEntity
        modelMapper.addMappings(new PropertyMap<AppointmentUpdateRequestDTO, AppointmentDetailEntity>() {
            @Override
            protected void configure() {
                skip().setPatient(null);
                skip().setDoctor(null);
                skip().setClinic(null);
                skip().setId(null);
                // skip().setCreatedAt(null);
                // skip().setUpdatedAt(null);
            }
        });

        // AppointmentDetailEntity -> AppointmentDTO
        modelMapper.addMappings(new PropertyMap<AppointmentDetailEntity, AppointmentDTO>() {
            @Override
            protected void configure() {
                // Map patient details
                map().setPatientId(source.getPatient().getId());
                map().setPatientFullName(source.getPatient().getFirstName() + " " + source.getPatient().getLastName());
                // Map doctor details
                map().setDoctorId(source.getDoctor().getId());
                map().setDoctorFullName(source.getDoctor().getFirstName() + " " + source.getDoctor().getLastName());
                // Map clinic details
                map().setClinicId(source.getClinic().getId());
                map().setClinicName(source.getClinic().getName()); // Assuming name exists
            }
        });

        // --- Mappings for DoctorClinicAffiliation ---

        // DoctorClinicAffiliationRequestDTO -> DoctorClinicAffiliationEntity
        modelMapper.addMappings(new PropertyMap<DoctorClinicAffiliationRequestDTO, DoctorClinicAffiliationEntity>() {
            @Override
            protected void configure() {
                // Doctor and Clinic entities are fetched and set in service
                skip().setDoctor(null);
                skip().setClinic(null);
                // The composite ID is set from doctor/clinic entities in helper constructor or service
                skip().setId(null);
            }
        });

        // DoctorClinicAffiliationEntity -> DoctorClinicAffiliationDTO
        modelMapper.addMappings(new PropertyMap<DoctorClinicAffiliationEntity, DoctorClinicAffiliationDTO>() {
            @Override
            protected void configure() {
                // Map complex fields to simpler DTO fields
                map().setDoctorId(source.getDoctor().getId());
                map().setDoctorFullName(source.getDoctor().getFirstName() + " " + source.getDoctor().getLastName());
                map().setClinicId(source.getClinic().getId());
                map().setClinicName(source.getClinic().getName());
                // Direct mapping for id, joiningDate, roleInClinic, shiftDetails, charge
            }
        });

        return modelMapper;
    }
}